<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack-A-Mole</title>
</head>

<style>
    html,
    body {
        height: 100%;
        margin: 0;
        background: black;
        overflow: hidden;
        font: 14px system-ui, sans-serif;
    }

    /* HUD container in top-left */
    #ui {
        position: fixed;
        left: 10px;
        top: 10px;
        color: white;
        background: black;
        padding: 6px 10px;
        border-radius: 8px;
    }

    /* small spacing for HUD items */
    #ui span.item {
        margin-left: 8px;
    }

    #modeSelect {
        margin-left: 8px;
        background: #111;
        color: #fff;
        border: 1px solid #333;
        border-radius: 4px;
        padding: 2px 6px;
    }
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
}
</script>

<body>
    <!-- HUD: Timer, Stars (score), Misses, Streak (current consecutive hits), Combo (multiplier) -->
    <div id="ui">
        ‚è≤Ô∏è Time remaining: <span id="timer">30.0</span>
        <span class="item">‚≠ê Stars: <span id="stars">0</span></span>
        <span class="item">‚ùå Misses: <span id="misses">0</span></span>
        <span class="item">üî• Streak: <span id="streak">0</span></span>
        <span class="item">üí• Combo: <span id="combo">1.0</span></span>
        <span class="item">üèÜ Best Streak: <span id="best">0</span></span>
        <label class="item">Mode:
            <select id="modeSelect">
                <option value="Classic">Classic</option>
                <option value="Chaos">Chaos</option>
            </select>
        </label>
    </div>

    <script type="module">
        import * as THREE from "three";

        // Minimal game state
        let time = 30; // seconds remaining
        let score = 0; // stars collected
        let misses = 0; // missed clicks count
        let streak = 0; // current consecutive hits
        let bestCombo = 0; // highest streak achieved (best streak)
        let running = true;

        // Scene setup (camera, renderer, lights)
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0d12);
        const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 8);
        camera.lookAt(0, 0, 0);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Resize handling
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Lights
        const light = new THREE.HemisphereLight(0x9ecfff, 0x0b0d12, 0.9);
        scene.add(light);
        const dl = new THREE.DirectionalLight(0xffffff, 0.7);
        dl.position.set(3, 6, 4);
        scene.add(dl);

        // Ground plane
        const ground = new THREE.PlaneGeometry(10, 8);
        const material = new THREE.MeshStandardMaterial({ color: 0x0f172a, roughness: 0.9 });
        ground.rotateX(-Math.PI / 2);
        const groundMesh = new THREE.Mesh(ground, material);
        scene.add(groundMesh);

        // Hole positions (x, z)
        const holePositions = [
            new THREE.Vector3(-3, 0, 0),
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(3, 0, 0)
        ];

        // Create a torus ring for each hole position
        const ringShape = new THREE.TorusGeometry(0.7, 0.12, 12, 32);
        const ringMaterial = new THREE.MeshStandardMaterial({ color: 0xf97316 });
        const rings = holePositions.map(pos => {
            const r = new THREE.Mesh(ringShape, ringMaterial);
            r.rotation.x = -Math.PI / 2;
            r.position.copy(pos);
            r.position.y = 0.02;
            scene.add(r);
            return r;
        });

        // Base mole mesh (will clone)
        const moleShape = new THREE.SphereGeometry(0.55, 16, 14);
        const moleMaterial = new THREE.MeshStandardMaterial({ color: 0xf97316 });
        const baseMole = new THREE.Mesh(moleShape, moleMaterial);

        // Create mole instances for each hole
        const moles = holePositions.map(pos => {
            const m = baseMole.clone();
            m.position.copy(pos);
            m.position.y = -1; // hidden by default
            m.userData.time = 0; // animation timer
            scene.add(m);
            return m;
        });

        let popUpTimeClassic = 900; // ms
        let popUpTimeChaos = 450; // ms (faster)
        let popUpTime = popUpTimeClassic;
        let sincePopUp = 0; // ms since last pop up

        // Animation timing parameters (seconds)
        let upDuration = 0.5;
        let downDuration = 0.5;
        let holdDuration = 0.012;
        const moleTopY = 0.9;

        function hideMole(m) {
            m.position.y = -1;
            m.userData.time = 0;
        }
        // Initially hide all
        moles.forEach(hideMole);

        // Raycaster for mouse clicks
        const ray = new THREE.Raycaster(); // raycaster from mouse position to 3D scene points
        const pt = new THREE.Vector2(); // 2D point for mouse

        const elementTimer = document.getElementById('timer');
        const elementStars = document.getElementById('stars');
        const elementMisses = document.getElementById('misses');
        const elementStreak = document.getElementById('streak');
        const elementCombo = document.getElementById('combo');
        const elementBest = document.getElementById('best');
        const modeSelect = document.getElementById('modeSelect');

        // Update HUD values
        function updateUI(currentCombo) {
            elementTimer.textContent = time.toFixed(1);
            elementStars.textContent = score;
            elementMisses.textContent = misses;
            elementStreak.textContent = streak;
            elementCombo.textContent = (currentCombo || combo()).toFixed(1);
            elementBest.textContent = bestCombo;
        }

        function combo() {
            // combo = min(1 + streak/5, 5)
            return Math.min(1 + streak / 5, 5);
        }

        const canvas = renderer.domElement;
        function ndcFromEvent(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: ((e.clientX - rect.left) / rect.width) * 2 - 1,
                y: -((e.clientY - rect.top) / rect.height) * 2 + 1
            };
        }

        // Pointer handler: count hits and misses, apply combo multiplier to score
        function onPointer(e) {
            if (!running) return;
            const ndc = ndcFromEvent(e);
            pt.x = ndc.x;
            pt.y = ndc.y;
            ray.setFromCamera(pt, camera);

            // Check intersections with all mole meshes
            const hits = ray.intersectObjects(moles, false);

            // Find first visible mole hit
            let hitMole = null;
            for (const h of hits) {
                if (h.object.position.y > -0.2) {
                    hitMole = h.object;
                    break;
                }
            }

            if (hitMole) {
                // Successful hit
                streak++;
                if (streak > bestCombo) bestCombo = streak;
                const currentCombo = combo();
                const points = Math.round(currentCombo); // apply combo to points gained
                score += points;
                // hide this mole immediately
                hideMole(hitMole);
                // reset popup timer so next spawn waits for configured time
                sincePopUp = 0;
                updateUI(currentCombo);
            } else {
                // Missed click (either didn't hit mole or mole not visible)
                misses++;
                streak = 0; // reset current streak on miss
                updateUI();
            }
        }

        // attach pointer handler to the canvas so clicks register
        renderer.domElement.addEventListener('pointerdown', onPointer, false);

        // Mode handling
        function applyMode(m) {
            if (m === 'Chaos') {
                popUpTime = popUpTimeChaos;
                // optionally make pop faster visually
                upDuration = 0.45;
                downDuration = 0.45;
            } else {
                popUpTime = popUpTimeClassic;
                upDuration = 0.5;
                downDuration = 0.5;
            }
            // hide all on mode change
            moles.forEach(hideMole);
            sincePopUp = 0;
        }
        modeSelect.addEventListener('change', (e) => applyMode(e.target.value));
        applyMode(modeSelect.value);

        // Helper: choose hidden mole indices
        function hiddenIndices() {
            const arr = [];
            moles.forEach((m, i) => {
                if (m.position.y <= -0.9) arr.push(i);
            });
            return arr;
        }

        // Start popup for given mole index
        function startPopup(idx) {
            const m = moles[idx];
            // only start if currently hidden
            if (m.position.y <= -0.9) {
                m.userData.time = 0; // start animation
            }
        }

        // Game loop: updates timing, mole animation, and rendering
        let last = performance.now();
        updateUI();

        function loop(now) {
            requestAnimationFrame(loop);
            const delta = Math.min((now - last) / 1000, 0.5); // seconds since last frame
            last = now;

            if (running && time > 0) {
                time = Math.max(0, time - delta);
                sincePopUp += delta * 1000;

                // Time to start a popup cycle
                if (sincePopUp >= popUpTime) {
                    // Determine how many to spawn
                    const mode = modeSelect.value;
                    let spawnCount = 1;
                    if (mode === 'Chaos' && Math.random() < 0.35) spawnCount = 2; // sometimes spawn two
                    const hidden = hiddenIndices();
                    // choose up to spawnCount distinct hidden indices
                    for (let s = 0; s < spawnCount && hidden.length > 0; s++) {
                        const idx = hidden.splice(Math.floor(Math.random() * hidden.length), 1)[0];
                        startPopup(idx);
                    }
                    sincePopUp = 0;
                }

                // Animate each mole independently
                moles.forEach(m => {
                    const userData = m.userData;
                    userData.time = (userData.time || 0) + delta; // seconds

                    const totalCycle = upDuration + holdDuration + downDuration;

                    if (userData.time > 0 && userData.time < upDuration) {
                        const t = userData.time / upDuration;
                        const eased = THREE.MathUtils.smoothstep(t, 0, 1);
                        m.position.y = -1 + eased * moleTopY;
                    } else if (userData.time >= upDuration && userData.time < upDuration + holdDuration) {
                        m.position.y = -1 + moleTopY;
                    } else if (userData.time >= upDuration + holdDuration && userData.time < totalCycle) {
                        const t = (userData.time - upDuration - holdDuration) / downDuration;
                        const eased = THREE.MathUtils.smoothstep(t, 0, 1);
                        m.position.y = -1 + moleTopY * (1 - eased);
                    } else if (userData.time >= totalCycle) {
                        // finished cycle: hide and reset
                        hideMole(m);
                    } else {
                        // inactive
                        m.position.y = -1;
                    }
                });

                // When time runs out stop game and show final stats
                if (time === 0) {
                    running = false;
                    alert(`Time's up! You scored ${score} stars.\nMisses: ${misses}\nBest Streak: ${bestCombo}\nFinal Streak: ${streak}`);
                }

                updateUI();
            }

            renderer.render(scene, camera);
        }

        requestAnimationFrame(loop);
    </script>
</body>

</html>
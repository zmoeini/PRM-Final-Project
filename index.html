<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />

<head>
  <meta charset="UTF-8">
  <title>Three.js Setup</title>
  <script type="importmap">
    {
        "imports":{
            "three" : "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
        }
    }
  </script>
</head>

<body style="margin: 0;">


<script type="module">

import * as THREE from 'three';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js';

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 50, 100);
camera.lookAt(0, 0, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
addEventListener('resize', () =>{
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
});



class Body {
  constructor(pos, color, initialVelocity, size, mass) {
    this.color = color;
    
    this.velocity = initialVelocity;

    this.size = size;
    this.sphereGeometry = new THREE.SphereGeometry(size, 32, 32); 
    this.material = new THREE.MeshStandardMaterial({color: color});

    this.mass = mass;

    this.mesh = new THREE.Mesh(this.sphereGeometry, this.material);
    this.mesh.position.copy(pos);
    scene.add(this.mesh);
  }

  getPos() {
    return this.mesh.position;
  }

  addPos(delta) {
    this.mesh.position.add(delta);
  }

}

class Sun extends Body {
  constructor(pos, size, mass) {
    super(pos, 0xffff00, new THREE.Vector3(0,0,0), size, mass);
    this.mesh.material = new THREE.MeshStandardMaterial({
      color: 0xffff00,
      emissive: 0xffaa00,
      emissiveIntensity: 10
    });
    const sunLight = new THREE.PointLight(0xffffff, 3000, 0);
    this.mesh.add(sunLight);
  }
}


class Simulation {
    
  constructor(g) {
    this.g = g;
    this.bodies = []
  }

  add(body) {
    this.bodies.push(body);
  }

  // Weighted average
  calculateMassCenter() {
    let sum = new THREE.Vector3(0, 0, 0);
    let sumMass = 0;
    for (let i = 0; i < this.bodies.length; i++) {
        let pos = this.bodies[i].getPos();
        let mass = this.bodies[i].mass;
        sumMass += mass;
        sum.add(new THREE.Vector3(pos.x * mass, pos.y * mass, pos.z * mass));
    }
    return new THREE.Vector3(sum.x / sumMass, sum.y / sumMass, sum.z / sumMass)
  }

  // Gravity simulation
  tick(dt) {
    // Calculate mass center of all the bodies
    const massCenter = this.calculateMassCenter();
    // For every body
    for (let i = 0; i < this.bodies.length; i++) {
        let force = new THREE.Vector3(0, 0, 0);
        let currentBody = this.bodies[i];
        // Calculate a force from every other body pulling current
        for (let j = 0; j < this.bodies.length; j++) {
            // The body that's pulling current
            let pullingBody = this.bodies[j];
            // vector: pulling - current 
            let delta = pullingBody.getPos().clone().sub(currentBody.getPos());
            let distance = delta.length();
            // Don't simulate if the bodies are too close
            if (distance < 1) {
                continue;
            }
            let multiplier = this.g * currentBody.mass * pullingBody.mass / distance / distance / distance; 
            force.add(delta.multiplyScalar(multiplier));
        }
        // divide force by mass to find acceleration
        currentBody.velocity.add(force.multiplyScalar(dt / currentBody.mass));
        currentBody.addPos(currentBody.velocity.clone().multiplyScalar(dt));
    }
  }

}

// Mouse
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.minDistance = 50;
controls.maxDistance = 500;

scene.add(new THREE.AmbientLight(0xffffff, 0.06));

// g acceleration
let simulation = new Simulation(1);

// A massive object in the center
let sun = new Sun(new THREE.Vector3(0, 0, 0), 8, 1000);
simulation.add(sun);

// For clarity of camera position (absence of background doesn't let it be cool)
function addGrid(size, divisions, axesColor, linesColor, opacity) {
    const grid = new THREE.GridHelper(size, divisions, axesColor, linesColor);
    grid.position.y = -sun.size;
    grid.material.transparent = true;
    grid.material.opacity = opacity
    scene.add(grid);
}
addGrid(200, 20, 0xff00ff, 0xffff00, 0.2);


for (let i = 0; i < 8; i++) {
    
    let distance = 15 + i * 10;

    // A random point close the the disk
    let position = new THREE.Vector3(Math.random() - 0.5, (Math.random() - 0.5) / 20, Math.random() - 0.5);
    position.normalize();
    position.multiplyScalar(distance);

    let r = position.clone();
    let axis = new THREE.Vector3(0, 1, 0);
    // Cross product to find a direction perpendicular to both axes (disk rotation and sun direction)
    let direction = new THREE.Vector3().crossVectors(r, axis).normalize();
    // Magic number 30 to balance the system. TODO: put all magic numbers as constants or even controled by user.
    let speed = 30 / Math.sqrt(distance);
    let velocity = direction.multiplyScalar(speed);

    let red = 0.5 + Math.random() * 0.3; // Not so red
    let green = Math.random() * 0.7 + 0.3; // More green
    let blue = Math.random() * 0.8 + 0.2; // MORE blue
    let color = new THREE.Color(red, green, blue); // Float-base color representation

    let planet = new Body(position, color, velocity, 2, 3); // size and mass

    simulation.add(planet);
}

let clock = performance.now();
function loop(now) {
  requestAnimationFrame(loop);
  // If less than 10 fps, the game slows down rather than simulating with high delay
  const dt = Math.min((now - clock) / 1000, 0.1);
  clock = now;

  
  

  const simulationStepDt = 0.001; // dt of every step of the simulation
  const steps = dt / simulationStepDt; // how many steps of a constant dt to cover the actual dt
  for (let i = 0; i < steps; i++) {
    simulation.tick(simulationStepDt); // simulate gravity
  }

  controls.update(); // Update mouse
  renderer.render(scene, camera);
}

loop(0);
</script>
</body>
</html>
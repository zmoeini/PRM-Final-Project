<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Whack‑a‑Mole — Tiny</title>
  <style>
    html,body{margin:0;height:100%;background:#0b0d12;overflow:hidden;font:14px system-ui}
    #ui{position:fixed;left:10px;top:10px;color:#e2e8f0;background:#0f172a; padding:6px 10px;border-radius:8px}
  </style>
  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
</head>
<body>
  <div id="ui">⏱ <span id="t">30.0</span>s · ⭐ <span id="s">0</span></div>
  <script type="module">
    import * as THREE from 'three';
 
    // --- minimal state ---
    let time = 30, score = 0, running = true;
 
    // --- three setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0d12);
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 100);
    camera.position.set(0, 6, 8); camera.lookAt(0,0,0);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight); document.body.appendChild(renderer.domElement);
    addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)});
 
    scene.add(new THREE.HemisphereLight(0x9ecfff,0x0b0d12,0.9));
    const dl = new THREE.DirectionalLight(0xffffff,0.7);
    dl.position.set(3,6,4); scene.add(dl);
 
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(12,12), new THREE.MeshStandardMaterial({color:0x0f172a,roughness:.9}));
    ground.rotation.x=-Math.PI/2; scene.add(ground);
    
    //*New* going to add 9 mole holes using three.Vector --> will also have to adjust how the mole spawning works later
    const holePositions = [
      new THREE.Vector3(-4,0,-4),
      new THREE.Vector3(0,0,-4),
      new THREE.Vector3(4,0,-4),
      new THREE.Vector3(-4,0,0),
      new THREE.Vector3(0,0,0),
      new THREE.Vector3(4,0,0),
      new THREE.Vector3(-4,0,4),
      new THREE.Vector3(0,0,4),
      new THREE.Vector3(4,0,4),
    ];

    //need to make a mole class and an array of moles now so we can loop through and spawn at positions
    class Mole 
    {
      constructor(position)
      {
        this.hiddenPosY = -0.8;
        this.mole = new THREE.Mesh(new THREE.SphereGeometry(.55,16,14), new THREE.MeshStandardMaterial({color:0xf97316}));
        this.mole.position.set(position.x, this.hiddenPosY, position.z); // hidden (below ground)
        scene.add(this.mole);
        this.t = 0; // initializing the anim frame to be at 0 aka hidden
      }

      ResetPosition() //giving mole a method to reset its position (so it the code is cleaner in the loop)
      {
        this.mole.position.y = this.hiddenPosY;
        this.t = 0;
      }

      UpdateMoles(dt) //method to update the mole position based on time
      {
        this.t += dt * 1.8;
        const up = this.t < 0.5;
        const t = up ? this.t / 0.5 : (this.t - 0.5) / 0.5;
        const y = up ? THREE.MathUtils.smoothstep(t, 0, 1) * 0.9 : 0.9 * (1 - THREE.MathUtils.smoothstep(t, 0, 1));
        this.mole.position.y = (this.t >= 1) ? this.hiddenPosY : y;
        if (this.t >= 1)
        {
          this.ResetPosition();
        } 
      }
    }
    const moles = holePositions.map(pos => new Mole(pos));

    // hole ring
    const ring = new THREE.Mesh(new THREE.TorusGeometry(.7,.12,12,32), new THREE.MeshStandardMaterial({color:0x334155}));
    ring.rotation.x=-Math.PI/2; ring.position.y=0.02; scene.add(ring);
 
    // mole sphere
    // const mole = new THREE.Mesh(new THREE.SphereGeometry(.55,16,14), new THREE.MeshStandardMaterial({color:0xf97316}));
    // mole.position.y = -0.8; // hidden (below ground)
    // scene.add(mole);
 
    // spawn every ~1s, speeds up slightly
    let spawnMs = 900, sinceSpawn = 0;
    // function spawn(){ mole.position.y = -0.8; mole.userData.t = 0; }
    // spawn();
 
    // click = raycast
    const ray = new THREE.Raycaster(); const pt = new THREE.Vector2();
    function onPointer(e){
       if(!running) return;
        pt.x=(e.clientX/innerWidth)*2-1;
        pt.y=-(e.clientY/innerHeight)*2+1;
        ray.setFromCamera(pt,camera);
      const hit = ray.intersectObject(mole,false)[0];
      if(hit)
      { score++; mole.position.y=-0.8; updateUI(); }
    }
    addEventListener('pointerdown', onPointer, {passive:true});
 
    // ui
    const tEl = document.getElementById('t'), sEl = document.getElementById('s');
    function updateUI(){ tEl.textContent=time.toFixed(1); sEl.textContent=score; }
 
    // loop
    let last = performance.now(); updateUI();
    function loop(now){
      requestAnimationFrame(loop);
       const dt=Math.min((now-last)/1000, .05); last=now;
      if(running && time>0)
      {
        time=Math.max(0,time-dt);
        sinceSpawn+=dt*1000;
        spawnMs =Math.max(450, spawnMs-0.15);

        if(sinceSpawn>=spawnMs)
        { 
          sinceSpawn=0;
          const randomMole = moles[Math.floor(Math.random() * moles.length)]; //selecting a random mole from the array
          randomMole.ResetPosition();
          //mole.position.y=-0.8; 
          //mole.userData.t=0; 
        }
        moles.forEach(element => 
        {
          element.UpdateMoles(dt);
        });
        // simple pop anim up then down in ~0.9s
        // const ud=mole.userData; 
        // ud.t=(ud.t||0)+dt*1.8;
        // const up=ud.t<0.5;
        // const t=up?ud.t/0.5:(ud.t-0.5)/0.5;
        // const y = up ? THREE.MathUtils.smoothstep(t,0,1)*0.9 : 0.9*(1-THREE.MathUtils.smoothstep(t,0,1));
        // mole.position.y = (ud.t>=1)? -0.8 : y;
        //if(ud.t>=1) spawn();
        if(time===0)
        { 
          running=false; 
          alert('Game Over — score: '+score); 
        }
        updateUI();
      }
      renderer.render(scene,camera);
    }
    requestAnimationFrame(loop);
  </script>
</body>
</html>
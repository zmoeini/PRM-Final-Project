<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack a Mole</title>
</head>
<style>
    html,body{
        margin:0;
        height:100%;
        background: black;
        overflow: hidden;
        font:14px system-ui;
        cursor: crosshair; /* makes cursor look like a crosshair for aiming */
    }
    #ui{
        position:fixed;
        left:10px;
        top:10px;
        color:white;
        background: black;
        padding: 6px 10px;
        border-radius:8px ;
    }
</style>
<script type="importmap">
{
   "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
}
</script>

<body>
     <div id="ui"> 
        ‚è±<span id="time">30.0</span>time
        ‚≠ê<span id="score">0</span> score 
        ‚ùå<span id="misses">0</span> misses  
        üî•<span id="streak">0</span> streak  
        ‚ö°<span id="combo">0</span> combo
    </div>
    <script type="module">
         import * as THREE from 'three';
        //minimal state
        let time = 30;
        let score = 0;
        let running = true;
        let misses = 0; 
        let streak = 0; 
        let combo = 0;
        //pop up setup
        let popUpTime = 900;
        let sincePopUp = 0;
        let moleIsUp = false;

//Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0b0d12);
        const camera = new THREE.PerspectiveCamera(55,innerWidth/innerHeight, 0.1, 1000);
        camera.position.set(0,6,8); //Camera little above and behind
        camera.lookAt(0,0,0); //look at center
        //renderer
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(innerWidth,innerHeight);
        document.body.appendChild(renderer.domElement);
        //resize event
        window.addEventListener('resize', () => 
            {
                camera.aspect = innerWidth/innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(innerWidth,innerHeight);
            }
        );
        //Hemisphere Light
        const light = new THREE.HemisphereLight(0x9ecfff, 0x0b0d12, 0.9);
        const dl = new THREE.DirectionalLight(0xffffff, 0.7); //directional light 
        dl.position.set(3,6,4);
        scene.add(light);
        scene.add(dl);
        //Ground
        const groundShape = new THREE.PlaneGeometry(10,8);
        const material = new THREE.MeshStandardMaterial({color:0x0f172a, roughness:0.9});
        const ground = new THREE.Mesh(groundShape, material);
        ground.rotation.x = -Math.PI/2; //make flat
        scene.add(ground);
        //Ring
        const ringShape = new THREE.TorusGeometry(0.7, 0.12, 12, 32);
        const ringMaterial = new THREE.MeshStandardMaterial({ color: 0xf97316, roughness: 0.3 });
        const ring = new THREE.Mesh(ringShape, ringMaterial);
        ring.rotation.x = -Math.PI / 2; //make flat
        ring.position.y = 0.02; //little above ground
        scene.add(ring);
        //Mole
        const moleShape = new THREE.SphereGeometry(0.55, 16, 14);
        const moleMaterial = new THREE.MeshStandardMaterial({color:0xf97316});
        const mole = new THREE.Mesh(moleShape, moleMaterial);
        mole.position.y = -0.8; //start below ground
        scene.add(mole);

//usable functions
        function popUp(){
            mole.position.y = -0.8; //start underground
            mole.userData.t = 0; //timer to track how long mole has been up.
            moleIsUp = true;
            sincePopUp = 0; //reset timer for next pop up
        }
        popUp(); //initial hide call

        //Loop UI
        function updateUI() {
            document.getElementById('time').textContent = time.toFixed(1); // (1 decimal)
            document.getElementById('score').textContent = score;
            document.getElementById('misses').textContent = misses;
            document.getElementById('streak').textContent = streak; 
            document.getElementById('combo').textContent = combo;
        }
        // reset mole 
        function resetMole() {
            mole.position.y = -0.8; 
            moleIsUp = false; // mark that mole is down
        }

        // when Mole is hit
        function hitMole() {
            if (!moleIsUp || mole.position.y < 0.3) {
                return; // don't count if mole is underground or still rising
            }
            score ++;
            streak++; 
            if (streak > combo) combo = streak;   
        //reset
            resetMole();   
            sincePopUp = 0; 
        }


// Pointer down event
         //Raycasting setup
        const ray = new THREE.Raycaster();
        const mouse = new THREE.Vector2(); // 2D vector for mouse

        window.addEventListener("pointerdown", (e) => {
            if (!running) return;

            mouse.x = (e.clientX / innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / innerHeight) * 2 + 1;

            ray.setFromCamera(mouse, camera); 
            const hit = ray.intersectObject(mole);
            if (hit.length > 0) { 
                hitMole(); // call hit
            }});

//Main loop
        let last = performance.now();

        function animate(t) {
            requestAnimationFrame(animate);
            const dt = Math.min((t-last)/1000, 0.05); 
            last = t;

            if (running) {  //is game still running?
                time -= dt; //let timer run

                if (time == 0) { //game over case
                    time = 0;
                    combo = 0;
                    running = false; 
                    alert("Game Over!");
                }

                //update mole timing
                sincePopUp += dt * 1000; 

                //animate mole up
                if (moleIsUp) {
                    mole.userData.t += dt * 1000; //how long mole has been up
                    if (mole.userData.t < 300) { //until 300ms passed
                        mole.position.y = -0.8 + (1.3 * (mole.userData.t / 300)); //move up smoothly
                    } 
                    else {
                        //keep at top until popUpTime
                        mole.position.y = 0.5;
                    }
                    //count miss if no hit was registered after popUpTime
                    if (mole.userData.t > popUpTime) {
                        misses++; 
                        streak = 0;  
                        resetMole(); 
                        sincePopUp = 0; 
                    }
                }
                //repeat Mole pop up when ready
                if (sincePopUp >= popUpTime && !moleIsUp) {
                    popUp(); 
                }
            }

            // Render, UI
            updateUI();
            renderer.render(scene, camera);
        }

        animate(performance.now());
    </script>
</body>
</html>
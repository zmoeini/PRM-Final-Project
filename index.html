<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Whack a Mole</title>
</head>
<style>
    html,body{
        margin: 0;
        height: 100%;
        background-color: black;
        overflow: hidden;
        font: 14px system-ui;
    }
    #ui{
        position: fixed;
        left: 10px;
        top: 10px;
        color: azure;
        background-color: black;
        padding: 6px 10px;
        border-radius: 8px;

    }
</style>
<script type="importmap">
    {
        "imports":
            {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
    }
</script>
<body>
<div id="ui"> ⏱<span id="t">30.0</span>s. ⭐<span id="s">0</span></div>

    <script type = "module">
        import * as THREE from 'three';

        //minimal state
        let time = 30;
        let score = 0;
        let running = true;

        //WEEK1--three--setup
        const scene = new THREE.Scene(); //create scene
        scene.background = new THREE.Color(0x0b0d12); //adding bg color to scene
        const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight,0.1,100); //create perspective cam
        camera.position.set(0,6,8); //set position
        camera.lookAt(0,0,0); //looks at the center of the screen/scene

        const renderer = new THREE.WebGLRenderer({antialias: true}); //create the renderer using WebGL
        renderer.setSize(innerWidth,innerHeight); //set to to window size
        //where should we show the renderer(which element--> body)
        document.body.appendChild(renderer.domElement);
        //resize
         //if anything happensa to the window size 
        addEventListener('resize',() =>
        {
            camera.aspect = innerWidth/innerHeight; //update the ratio
            camera.updateProjectionMatrix(); //update the cam matrix
            renderer.setSize(innerWidth,innerHeight); //update renderer size
        }
    );

    //Hemispherre Light
    const light = new THREE.HemisphereLight(0x9ecfff,0x0b0d12,0.9); //sky color, ground color, transparency
    scene.add(light); //add to scene   

    const dLight = new THREE.DirectionalLight(0xffffff,0.7); // color and transparency
    dLight.position.set(3,6,4); //set position
    scene.add(dLight); //adds to scene

    const groundShape = new THREE.PlaneGeometry(10,8); //creates a plane 
    const material = new THREE.MeshStandardMaterial({color:0x0f172a, roughness:0.9}); //adds mat color and roughness
    const ground = new THREE.Mesh(groundShape,material); //create the mesh
    ground.rotation.x = -Math.PI/2; //rotates to show up on the ground
    scene.add(ground); //add to scnene

    //ring or donut-sahped ring
    const ringShape = new THREE.TorusGeometry(0.7,0.12,12,32);
    // 0.7 ring size (outer radius)
    // 0.12 = ring thickness(tube radius)
    //32 how many segments around the big circle
    const ringMaterial = new THREE.MeshStandardMaterial({color:0xf97316});
    const ring = new THREE.Mesh(ringShape,ringMaterial);
    ring.rotation.x = Math.PI/2; //ring flat
    ring.position.y = 0.02; //pos y lifts ring above the ground
    scene.add(ring);

    //mole sphere
    const moleShape = new THREE.SphereGeometry(0.55,16,14); //craete sphere radius -- width --height
    const moleMaterial = new THREE.MeshStandardMaterial({color:0xf97316});
    const mole = new THREE.Mesh(moleShape,moleMaterial);
    mole.position.y =-0.8; //hidden (underground)
    scene.add(mole);

    let popUpTime = 900;
    //we plan to popup the mole about every 900milisecs (1sec)
    let sincePopUp = 0;
    //tracks how long from last popup

    function PopUp(){
        //hide mole underground
        mole.position.y = -0.8;
        mole.userData.t = 0;  //restart timer to know popup 
        sincePopUp = 0; //reset timer after popup
    }

    PopUp(); //popup once

    //what is raycasting 
    //imanginary ray straight line and hits

    //2D mouse pos
    //mouse.x = (e.clientx /window.innerwidth)*2 -1
    //coordiantion represents cam view plane 
    
    const ray = new THREE.Raycaster(); // create a laser beam that will shoot from thge camera from user perspectiev throught the pos 
//through the ps in 3d world

    const  pTime = new THREE.Vector2();// a 2D point to hold the mosue /touch pos

    //update UI reset the score anf put the game at the start 

    const elementT = document.getElementById('t'); //time
    const elementS = document.getElementById('s'); //stars/score

    function updateUI(){
        
        elementT.textContent = time.toFixed(1); //fixes to 1 decimal place
        elementS.textContent = score;
        
    }
    //input function
    function onPointer(e)
    {
        //if the game is active 
        if(!running) return; //break the function --stop the function

        //ttake the mouse /touch pos and convert to NDC
        pTime.x = (e.clientX /innerWidth)*2 -1;
        //x become a value from -1 (left) to +1(right)
        pTime.y = -(e.clientY /innerHeight)*2 +1;

        //ray goes from cam to point in the game
        ray.setFromCamera(pTime,camera);
        
        const hit = ray.intersectObject(mole,false)[0];
        //fire the ray and check if it hits the mosue 
        //false means does not search insaide the meshes 
        //[0] grab closest hit

        //if it hits happened I wil give 1 score
        if(hit){
            score++;
            //put mole in the base pos
            mole.position.y = -0.8;//under the ground
            updateUI();
        }


    }//End of onPointer

    addEventListener('pointerdown', onPointer); //event for mouse click or input

    //LOOP
    //get the last i need delta time for my frames 
    let last = performance.now();
    updateUI();

    //loop is your game heartbeat 
    function loop(){

    //call loop 
    requestAnimationFrame(loop);

    const now = performance.now(); //current time in milisecs
    const dt = Math.min((now-last)/1000,0.05); //delta time in seconds
    last = now;
    //(now-last) = how lonmg since last frame in milisecs
    //divide by 1000 to get seconds
    //Math.min(....,.05)

    //running - game is active and time + value (it is not game over)
    if(running && time > 0)
    {
        time = Math.max(time - dt, 0); //reduce the time base don the frames passed
        //popup 
        //track how many ms since the last popup
        sincePopUp += dt*1000; //dt is in seconds convert to milisecs

        //1-check if its time to popup the mole
        if(sincePopUp > popUpTime)
        {
            PopUp();
            mole.position.y= -0.8; //underground
            mole.userData.t = 0; 
            //sincepopup how much time passed since last mole appeared
            //popup time how many ms to wait before popping up again

            //sincePopUp >= popUpTime if enough time has passed 
            //reset sincePopUp to zero 
        }
        //we manage our loop in 8 steps
        
        //2-getting and updating the mole anim state

        const userData = mole.userData;
        userData.t = (userData.t||0) + dt * 1.8; //time since popup in seconds


        //3-determine whether the mole si going up or down
        const up = userData.t < 0.5; 
        //if more than .5sec mole is going up
        //if more than .5sec mole is going down


        //4-normalize time for anim
        const t = up ? userData.t / 0.5 : (userData.t - 0.5) / 0.5;
        //when going up t goes from 0 to 1 in 0.5sec
        //when going down t goes from 0 to 1 in 0.5sec
        //it makes anim simpler 

        //5-calculate y pos
        const y = up ? THREE.MathUtils.smoothstep(t,0,1) * 0.9 : 0.9 *(1-THREE.MathUtils.smoothstep(t,0,1));
        //smoothstep moves from 0 to 1 
        //when going up y goes from 0 to 0.9
        //everything smoother

        //6-apply new pos or rest
        //if whenthe mole is done up n down (t<1) 
        // we reset the mole pos underground
        mole.position.y = (userData.t < 1) ? y : -0.8;
        if(userData.t >= 1) PopUp();
        
    
        //7-end of game 
        if(time === 0){
            running = false;
            alert('Game Over! ' + score); //show score
        }
        updateUI();

    }
    renderer.render(scene,camera);

}

loop();

    </script>
    
</body>
</html>